
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=windows-1252"/>
	<title>Hog Project</title>
	<meta name="generator" content="LibreOffice 5.1.1.3 (Windows)"/>
	<meta name="created" content="2016-06-10T20:20:46.511000000"/>
	<meta name="changed" content="2016-06-10T21:10:33.049000000"/>
	<script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script>
	<link type="text/css" rel="stylesheet" href="../css/default.css" />
	<a href="index.html">Home</a>
</head>
<body lang="en-US" dir="ltr">
<h1 class="western">CS61A: Solving the Hog Final Strategy</h1>
<p>	Here&rsquo;s my version of solving the Fall 2015 version of the
game of hog. Here are rules, copied from the CS61A website:</p>
<p>
<br/>
<h2>Problem Definition:</h2>
<p>In Hog, two players alternate turns trying to be the first to end a turn with
at least 100 total points. On each turn, the current player chooses some number
of dice to roll, up to 10. That player's score for the turn is the sum of the
dice outcomes.</p>

<p>To spice up the game, we will play with some special rules:</p>

<ul>
  <li><strong>Pig Out</strong>. If any of the dice outcomes is a 1, the current player's score
  for the turn is 0.</li>
  <li><p><strong>Piggy Back</strong>. When the current player scores 0, the opposing player
  receives points equal to the number of dice rolled that turn.</p>

  <ul>
    <li><em>Example</em>: If the current player rolls 3 dice that come up 1, 5, and 1,
    then the current player scores 0 and the opponent scores 3.</li>
  </ul></li>
  <li><p><strong>Free Bacon</strong>. A player who chooses to roll zero dice scores one more
  than the largest digit in the opponent's total score.</p>

  <ul>
    <li><em>Example 1</em>: If the opponent has 42 points, the current player gains 1 +
    max(4, 2) = 5 points by rolling zero dice.</li>
    <li><em>Example 2</em>: If the opponent has has 48 points, the current player gains
    1 + max(4, 8) = 9 points by rolling zero dice.</li>
    <li><em>Example 3</em>: If the opponent has has 7 points, the current player gains
    1 + max(0, 7) = 8 points by rolling zero dice.</li>
  </ul></li>
  <li><strong>Hog Wild</strong>. If the sum of both players' total scores is a multiple
  of seven (e.g., 14, 21, 35), then the current player rolls four-sided
  dice instead of the usual six-sided dice.</li>
  <li><strong>Hogtimus Prime</strong>. If a player's score for the turn is a prime number, then
  the turn score is increased to the next largest prime number. For example, if
  the dice outcomes sum to 19, the current player scores 23 points for the
  turn. This boost only applies to the current player. <em>Note:</em> 1 is not a prime
  number!</li>
  <li><p><strong>Swine Swap</strong>. After the turn score is added, if the last two digits of each
  player's score are the reverse of each other, the players swap total scores.</p>

  <ul>
    <li><em>Example 1</em>: The current player has a total score of 13 and the opponent
    has 91. The current player rolls two dice that total 6. The last two
    digits of the current player's new total score (19) are the reverse of
    the opponent's score (91). These scores are swapped! The current player
    now has 91 points and the opponent has 19. The turn ends.</li>
    <li><em>Example 2</em>: The current player has 66 and the opponent has 8. The
    current player rolls four dice that total 14, leaving the current player
    with 80. The reverse of 80 is 08, the opponent's score. After the swap,
    the current player has 8 and the opponent 80. The turn ends.</li>
    <li><em>Example 3</em>: Both players have 90. The current player rolls 7 dice that
    total 17, a prime that is boosted to 19 points for the turn. The current
    player has 109 and the opponent has 90. The last two digits 09 and 90 are
    the reverse of each other, so the scores are swapped. The opponent ends
    the turn with 109 and wins the game.</li>
  </ul></li>
</ul>
<p><br/>
<br/>
</p>
<h2>Solve:</h2>
<p>This problem is recognizable as an Expectimax Tree. Simply put, an expectimax tree
is consisted of state nodes and action nodes. The tree is rooted at a state node
indicating the scores for both players at zero and zero, as well as who is about to
play. Each state either offers a set of possible action nodes or evaluates to a
discrete number of points which represents the number of points expected
(but not guaranteed) should a user reach that state.
Each action node has a value equal to the following summation:
</p>

<div lang="latex">
	$action's exp value = $Value(action) = \sum_{n=0}^{ps} expPoints(state_{n}) * prob(state_{n})\\
	\\
	\indent ps$ = possible states from current action$ \\
	\indent state_{n}$ = nth state visitable from action$ \\
	\indent expPoints(x)$ = number of expected points when visiting state $x \\
	\indent prob(x)$ = probability of reaching state $x$ when taking this action$ \\
	\\
</div>

<p>
Subsequently, each state node can also be quantized as a value, which would be equal
to the following equation:
</p>


<div lang="latex">
	Value(Node_x) = \{\max_{a_{0} \leq a_{i} \leq a_{10}} Value(a)\}
</div>

<p>
Given the value of the state node is equal to the value of the maximum valued action node,
the best move at the state node must be equal to the action that yields the maximum
expected value, or:
</p>


<div lang="latex">
	\DeclareMathOperator{\argmaxA}{arg\,max}_x Value(x) &= \{x \mid f(x) = Value(a_{x}) \}
</div>

<p> Or, if one prefers a solve with Dynamic Programming: </p>
<p>Here&rsquo;s my logical deduction on how a final strategy can be
developed:</p>
<ol>
	<li/>
<p>First, we recognize that given a score and opponent&rsquo;s
	score, there exists an optimal number of rolls. In other words, a
	best strategy exits for every score and opponent score</p>
	<p>a. In theory you could devise a 100 x 100 matrix and try every
	single combination of 0 &ndash; 10 in each of the elements and see
	which configuration gives you the highest avg score. However, there
	are about 11^10,000 combinations, which is too many to solve for&hellip;</p>
	<li/>
<p>The best number of rolls must the be number of rolls that
	maximizes our chances of winning. This is the definition of the best
	number of rolls.</p>
	<li/>
<p>Given 1 and 2, there must be a function such that, given
	score, opponent&rsquo;s score, and number of dice to roll (k), it
	returns the probability of winning by rolling k number of dice.</p>
	<li/>
<p>For the function works as follows: iterate through all
	possible points score-able by rolling k dice, find the (probability
	of scoring p with k dice) * (probability of winning with p points),
	and sum up all values. The sum is the probability of winning by
	rolling k dice.
	</p>
	<p>a. The probability of scoring p points with k dice is a simple
	statistical problem.
	</p>
	<p>b. The probability of winning with p points is a simple logical
	problem, described below:</p>
	<ol>
		<p>I. If my score + p points &gt;= 100, I&rsquo;ve already won.
		Return 1</p>
		<p>II. If my opponent&rsquo;s score &gt;= 100, I&rsquo;ve already
		lost. Return 0</p>
		<p>III. If it&rsquo;s not I or II, then I&rsquo;ve made my move,
		but no one has yet won. Now my opponent will roll d dice, where d
		is the optimal number of dice for him/her (or 5, if you are playing vs the AI).
		The probability we will win is the probability the opponent will
		not win with d dice, or 1 &ndash;
		probability opponent wins by rolling d dice.
		</p>
	</ol>
	<li/>
<p>Be aware: watch out for recursion depth, as it tends to get
	large. Also try storing things into tables so that we do not waste
	time calculating redundant things. aka Memoization
</p>
<p> Be aware: of the special rules and when they apply. I got really badly tripped up
since I didn't pay attention to the piggy back and piggy out rules. An interesting note is
if one ignores the piggy back rule, a minimax tree will be unable to solve the problem, since
there will be loops in the tree. Solving will require a Markov Decision Process.
</ol>
<p><br/>
<br/>

</p>
<p>	These logical steps should allow for the proper solving of the
CS61A Hog problem.
</p>
<p><br/>
<br/>

</p>
<h3>Sources used:</h3>

<p><a href="http://www.scsb.org/codingchallenge/pig.pdf">A PDF I found from a google search</a></p>
<p>Tips from CS Gods: Aurick Zhou and Alvin Kao</p>
<p>Pointers from: Morgan Reschenberg, Sandy Zhang, and Joan Zhu</p>
<p>Judgement from: Eric Liu, Andrew Chen</p>
</body>
</html>
